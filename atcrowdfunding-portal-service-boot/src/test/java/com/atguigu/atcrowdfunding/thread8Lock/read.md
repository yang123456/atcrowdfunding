link https://www.cnblogs.com/shamao/p/11045282.html
总结
一个类里面如果有多个synchronized方法，在使用同一个对象调用的前提下，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其他的线程都只能等待，换句话说，某一时刻内，只能有唯一一个线程去访问这些synchronized方法。

锁的是当前对象this，被锁定后，其他线程都不能进入到当前对象的其他的synchronized方法。

加个普通方法后发现和同步锁无关。

换成静态同步方法后，情况又变化。

所有的非静态同步方法用的都是同一把锁：实例对象本身。

也就是说如果一个对象的非静态同步方法获取锁后，该对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是其他对象的非静态同步方法因为跟该对象的非静态同步方法用的是不同的锁，所以毋须等待该对象的非静态同步方法释放锁就可以获取他们自己的锁。

所有的静态同步方法用的也是同一把锁：类对象本身。

这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间不会有竞争条件。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个对象的静态同步方法，还是其他对象的静态同步方法，只要它们属于同一个类的对象，那么就需要等待当前正在执行的静态同步方法释放锁。

